# Data Flow Analysis Prompt Template

## Overview

This document provides a refined prompt template for analyzing data flow through clean architecture layers, with emphasis on **Name**, **Component**, **Function**, and **Action** for any function or feature.

## Refined Prompt Template

**Prompt:**

"For a given function or feature [INSERT FUNCTION/FEATURE NAME], provide a detailed step-by-step data flow analysis by directly inspecting the relevant source files (using logs, debugging tools, or code comments, not memory). Structure the response to trace the data flow through clean architecture layers (presentation, application, domain, infrastructure) or Domain-Driven Design (DDD) principles, highlighting each component's role. For each step, include:

- **Name**: The specific component or layer involved.
- **Component**: The type of component (e.g., React component, use case, repository, service, database table).
- **Function**: A concise description of its role or purpose in the process.
- **Action**: The specific action it performs during the execution of the function/feature.

Explicitly include infrastructure details, such as specific Supabase tables, edge functions (if used), or other data stores, and note any dependency injection or violations of the Dependency Inversion Principle. Ensure the response respects clean architecture principles (e.g., no direct layer dependencies, proper use of interfaces). Do not include code snippets; provide a narrative description. Structure the output in a JSON format with sections for each layer (presentation, application, domain, infrastructure) and an infrastructure details section, similar to the provided example."

## Sample JSON Output Pattern

This sample mirrors the structure and detail level of the original output for creating a new function model, applied to a generic "Create Entity" feature, ensuring the **Name**, **Component**, **Function**, and **Action** format.

```json
{
  "feature": "Create Entity",
  "dataFlow": {
    "presentationLayer": [
      {
        "name": "EntityFormPage",
        "component": "React Component",
        "function": "Renders the UI form for entity creation and handles user interactions",
        "action": "User submits form, triggering 'handleCreateEntity()' which calls the use case"
      }
    ],
    "applicationLayer": [
      {
        "name": "EntityManagementUseCases",
        "component": "Use Case",
        "function": "Orchestrates business logic for entity creation, coordinating with domain and infrastructure",
        "action": "Calls 'createEntity()' method, passing form data to the repository"
      }
    ],
    "domainLayer": [
      {
        "name": "Entity",
        "component": "Domain Entity",
        "function": "Represents the business entity with validation rules, independent of infrastructure",
        "action": "Validates input data before passing to repository"
      }
    ],
    "infrastructureLayer": [
      {
        "name": "SupabaseEntityRepository",
        "component": "Repository",
        "function": "Handles database operations for entities via Supabase client",
        "action": "Inserts new entity into 'entities' table with generated UUID"
      },
      {
        "name": "AuditService",
        "component": "Service",
        "function": "Logs operations for compliance and tracking",
        "action": "Logs creation event to 'audit_log' table"
      },
      {
        "name": "DependencyContainer",
        "component": "Dependency Injection Container",
        "function": "Manages dependencies, ensuring loose coupling between layers",
        "action": "Injects repository and audit service into use cases"
      }
    ]
  },
  "infrastructureDetails": {
    "supabaseTables": [
      {
        "name": "entities",
        "function": "Stores entity data",
        "columns": ["entity_id", "name", "description", "created_at", "updated_at"]
      },
      {
        "name": "audit_log",
        "function": "Tracks operations for compliance",
        "columns": ["audit_id", "table_name", "operation", "record_id", "changed_by", "changed_at"]
      }
    ],
    "edgeFunctions": "None used; direct Supabase client operations handle database inserts.",
    "dependencyInjection": "Uses DependencyContainer to inject SupabaseEntityRepository and AuditService into use cases, adhering to Dependency Inversion Principle.",
    "dependencyInversionViolations": "None detected; domain layer depends on repository interfaces, not concrete implementations."
  },
  "dataFlowSequence": [
    "User submits form in EntityFormPage (Presentation).",
    "EntityFormPage calls EntityManagementUseCases.createEntity() (Application).",
    "Entity validates data (Domain).",
    "EntityManagementUseCases calls SupabaseEntityRepository.createEntity() (Infrastructure).",
    "SupabaseEntityRepository inserts into 'entities' table (Infrastructure).",
    "AuditService logs to 'audit_log' table (Infrastructure).",
    "Response with entity_id returned to EntityFormPage (Presentation)."
  ]
}
```

## Key Features

### Focus on Data Flow and Clean Architecture
- The prompt explicitly mandates tracing data flow through clean architecture layers (presentation, application, domain, infrastructure)
- Ensures alignment with DDD principles and emphasizes layer separation

### Name, Component, Function, Action Structure
- **Name**: The specific component or layer involved
- **Component**: The type of component (e.g., React component, use case, repository, service, database table)
- **Function**: A concise description of its role or purpose in the process
- **Action**: The specific action it performs during the execution of the function/feature

### File-Based Tracing
- Requires direct file inspection (via logs, debugging tools, or comments)
- Clarifies that this is the *method* of analysis, not the subject

### Infrastructure as Required
- Supabase tables, edge functions, and dependency injection details are mandatory
- Addresses concerns about weak "additionally" phrasing

### Generic for Any Function/Feature
- The template is flexible for any function or feature, not limited to creating a function model

### JSON Structure
- Mirrors the original response's detail and organization
- Clear sections for each layer and infrastructure details
- Ensures consistency across analyses

## Usage Guidelines

1. **Replace Placeholder**: Insert the specific function or feature name in the prompt template
2. **Direct File Inspection**: Always inspect source files directly, not from memory
3. **Layer Separation**: Maintain clear boundaries between presentation, application, domain, and infrastructure layers
4. **Infrastructure Details**: Always include specific database tables, services, and dependency injection patterns
5. **Clean Architecture Compliance**: Ensure no direct layer dependencies and proper use of interfaces
6. **Narrative Description**: Provide clear descriptions without code snippets

## Benefits

- **Consistency**: Standardized format for all data flow analyses
- **Completeness**: Ensures all architectural layers are covered
- **Clarity**: Clear structure with Name, Component, Function, Action format
- **Traceability**: Direct file-based analysis ensures accuracy
- **Architecture Compliance**: Enforces clean architecture principles
