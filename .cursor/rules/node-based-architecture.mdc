---
description: When creating features, implement node-based data models and connectivity
globs:
  - "lib/domain/entities/*-node-types.ts"
  - "lib/application/use-cases/*-node-operations.ts"
  - "lib/infrastructure/migrations/*.ts"
  - "components/composites/function-model/**/*.tsx"
alwaysApply: false
---
# Node-Based Architecture Design

## Overview

This document outlines the architectural design for a **node-based system** that maintains **separate database tables** for each feature while enabling **cross-feature node connectivity**. This approach addresses the scalability concerns of a unified node system while preserving the visual and functional benefits of node-based architecture.

## Current State Analysis

### Unified Node System (Current)
- **Single Table**: `nodes` table stores all node types
- **Type Discrimination**: Uses `type` and `node_type` fields to distinguish features
- **Metadata Storage**: Feature-specific data stored in JSONB `metadata` field
- **Scalability Issues**: Single table becomes complex to manage at scale
- **Query Performance**: Mixed node types can impact query performance

### Function Model Feature (Current)
- **Dedicated Table**: `function_models` table with specific schema
- **Rich Metadata**: Comprehensive function model specific fields
- **Version Control**: Built-in versioning system
- **Cross-Feature Links**: Separate `cross_feature_links` table
- **Node-Level Linking**: Individual nodes can link to other features

## Node Heterogeneity Analysis

### Critical Architectural Challenge

The nodes across different features are **fundamentally different** in nature, purpose, and behavior, but we need a **unified interface** for cross-feature connectivity and visualization. This is a core architectural challenge that must be addressed.

#### Node Type Characteristics

**1. Function Model Nodes (Process/Workflow Nodes)**
- **Nature**: High-level process mapping and workflow design
- **Purpose**: Represent stages, actions, decision points in business processes
- **Behavior**: 
  - Hierarchical relationships (parent-child)
  - Sequential flow (stage → stage)
  - Process-oriented (input → process → output)
  - Static structure with dynamic execution paths
- **Examples**: Stage nodes, action nodes, decision nodes, container nodes
- **Complexity**: High - complex business logic, multiple relationships
- **Lifecycle**: Long-term process definitions

**2. Knowledge Base Nodes (Content/Document Nodes)**
- **Nature**: Content management and documentation
- **Purpose**: Store, organize, and link knowledge artifacts
- **Behavior**:
  - Content-centric (SOPs, procedures, guidelines)
  - Reference-based relationships
  - Version-controlled content
  - Searchable and taggable
- **Examples**: SOP nodes, category nodes, template nodes
- **Complexity**: Medium - content management, versioning
- **Lifecycle**: Content evolution and updates

**3. Spindle Nodes (Integration/Automation Nodes)**
- **Nature**: Integration and automation workflows (similar to Make.com)
- **Purpose**: Connect systems, automate processes, handle data transformation
- **Behavior**:
  - Integration-focused (API calls, data transformation)
  - Event-driven (triggers and actions)
  - Real-time execution
  - Error handling and retry logic
- **Examples**: API nodes, trigger nodes, action nodes, data transformation nodes
- **Complexity**: High - integration logic, error handling, real-time execution
- **Lifecycle**: Dynamic execution and monitoring

**4. Event Storm Nodes (Domain/Event Nodes)**
- **Nature**: Domain modeling and event-driven architecture
- **Purpose**: Model business domains and event flows
- **Behavior**:
  - Domain-centric (business domains, bounded contexts)
  - Event-driven (event sourcing patterns)
  - Temporal relationships (before/after events)
  - Aggregate-based modeling
- **Examples**: Domain nodes, event nodes, aggregate nodes
- **Complexity**: High - domain modeling, event sourcing
- **Lifecycle**: Domain evolution and event history

### Abstraction Strategy

To handle this heterogeneity while maintaining a unified interface, we need a **multi-layered abstraction approach**:

#### 1. Base Node Interface (Common Properties)

```typescript
// lib/domain/entities/base-node-types.ts

export interface BaseNode {
  // Universal properties (all nodes share these)
  id: string
  featureType: FeatureType
  nodeType: string
  name: string
  description?: string
  
  // Visual representation (for unified visualization)
  position: { x: number; y: number }
  visualProperties: VisualProperties
  
  // Cross-feature connectivity
  metadata: NodeMetadata
  
  // Universal lifecycle
  createdAt: Date
  updatedAt: Date
  status: NodeStatus
}

export interface VisualProperties {
  color?: string
  icon?: string
  size?: 'small' | 'medium' | 'large'
  style?: Record<string, any>
  // Feature-specific visual properties
  featureSpecific?: Record<string, any>
}

export interface NodeMetadata {
  tags: string[]
  aiAgent?: AIAgentConfig
  vectorEmbedding?: number[]
  searchKeywords: string[]
  // Cross-feature linking metadata
  crossFeatureLinks?: CrossFeatureLinkMetadata[]
}

export type NodeStatus = 'active' | 'inactive' | 'draft' | 'archived' | 'error'
```

#### 2. Feature-Specific Node Interfaces

```typescript
// lib/domain/entities/function-model-node-types.ts

export interface FunctionModelNode extends BaseNode {
  featureType: 'function-model'
  nodeType: 'stageNode' | 'actionTableNode' | 'ioNode' | 'functionModelContainer'
  
  // Function Model specific properties
  functionModelData: {
    stage?: Stage
    action?: ActionItem
    io?: DataPort
    container?: FunctionModelContainer
  }
  
  // Process-specific behavior
  processBehavior: {
    executionType: 'sequential' | 'parallel' | 'conditional'
    dependencies: string[] // IDs of dependent nodes
    timeout?: number
    retryPolicy?: RetryPolicy
  }
  
  // Business logic properties
  businessLogic: {
    raciMatrix?: RACIMatrix
    sla?: ServiceLevelAgreement
    kpis?: KeyPerformanceIndicator[]
  }
}

// lib/domain/entities/knowledge-base-node-types.ts

export interface KnowledgeBaseNode extends BaseNode {
  featureType: 'knowledge-base'
  nodeType: 'sop' | 'category' | 'template'
  
  // Knowledge Base specific properties
  knowledgeBaseData: {
    sop?: SOP
    content: string
    category: string
    status: 'draft' | 'published' | 'archived'
  }
  
  // Content-specific behavior
  contentBehavior: {
    contentType: 'procedure' | 'guideline' | 'template' | 'reference'
    versioning: VersioningPolicy
    approvalWorkflow?: ApprovalWorkflow
    searchable: boolean
  }
  
  // Content properties
  contentProperties: {
    readTime: number
    complexity: 'simple' | 'moderate' | 'complex'
    targetAudience: string[]
    prerequisites: string[]
  }
}

// lib/domain/entities/spindle-node-types.ts

export interface SpindleNode extends BaseNode {
  featureType: 'spindle'
  nodeType: 'trigger' | 'action' | 'transformation' | 'condition' | 'errorHandler'
  
  // Spindle specific properties
  spindleData: {
    integrationType: 'api' | 'webhook' | 'database' | 'file' | 'custom'
    connector?: ConnectorConfig
    transformation?: TransformationConfig
  }
  
  // Integration-specific behavior
  integrationBehavior: {
    executionMode: 'synchronous' | 'asynchronous' | 'batch'
    rateLimit?: RateLimit
    timeout: number
    retryPolicy: RetryPolicy
    errorHandling: ErrorHandlingStrategy
  }
  
  // Technical properties
  technicalProperties: {
    apiEndpoint?: string
    authentication?: AuthenticationConfig
    dataMapping?: DataMappingConfig
    monitoring?: MonitoringConfig
  }
}

// lib/domain/entities/event-storm-node-types.ts

export interface EventStormNode extends BaseNode {
  featureType: 'event-storm'
  nodeType: 'domainNode' | 'eventNode' | 'aggregateNode' | 'policyNode'
  
  // Event Storm specific properties
  eventStormData: {
    domain?: Domain
    event?: Event
    aggregate?: Aggregate
    policy?: Policy
  }
  
  // Domain-specific behavior
  domainBehavior: {
    boundedContext: string
    aggregateRoot?: string
    eventSourcing: boolean
    cqrs: boolean
  }
  
  // Event properties
  eventProperties: {
    eventType: 'command' | 'event' | 'query'
    eventVersion: number
    eventSchema: Record<string, any>
    eventHandlers: string[]
  }
}
```

#### 3. Node Behavior Abstraction

```typescript
// lib/domain/entities/node-behavior-types.ts

// Abstract behavior interfaces for different node types
export interface NodeBehavior {
  canExecute(): boolean
  getDependencies(): string[]
  getOutputs(): any[]
  validate(): ValidationResult
}

export interface ProcessNodeBehavior extends NodeBehavior {
  execute(): Promise<ExecutionResult>
  rollback(): Promise<void>
  getExecutionPath(): string[]
}

export interface ContentNodeBehavior extends NodeBehavior {
  render(): string
  search(query: string): SearchResult[]
  version(): VersionInfo
}

export interface IntegrationNodeBehavior extends NodeBehavior {
  connect(): Promise<ConnectionResult>
  transform(data: any): Promise<any>
  handleError(error: Error): Promise<ErrorHandlingResult>
}

export interface DomainNodeBehavior extends NodeBehavior {
  handleCommand(command: any): Promise<Event[]>
  applyEvent(event: any): void
  getState(): any
}

// Factory for creating appropriate behavior based on node type
export class NodeBehaviorFactory {
  static createBehavior(node: BaseNode): NodeBehavior {
    switch (node.featureType) {
      case 'function-model':
        return new ProcessNodeBehavior(node as FunctionModelNode)
      case 'knowledge-base':
        return new ContentNodeBehavior(node as KnowledgeBaseNode)
      case 'spindle':
        return new IntegrationNodeBehavior(node as SpindleNode)
      case 'event-storm':
        return new DomainNodeBehavior(node as EventStormNode)
      default:
        throw new Error(`Unknown feature type: ${node.featureType}`)
    }
  }
}
```

#### 4. Cross-Feature Link Abstraction

```typescript
// lib/domain/entities/cross-feature-link-types.ts

export interface CrossFeatureLink {
  linkId: string
  sourceFeature: FeatureType
  sourceEntityId: string
  sourceNodeId?: string
  targetFeature: FeatureType
  targetEntityId: string
  targetNodeId?: string
  linkType: LinkType
  linkStrength: number
  linkContext: Record<string, any>
  visualProperties: VisualProperties
  createdBy: string
  createdAt: Date
  updatedAt: Date
}

// Link types that make sense across different node types
export type LinkType = 
  | 'references'      // One node references another
  | 'implements'      // One node implements another
  | 'documents'       // One node documents another
  | 'supports'        // One node supports another
  | 'nested'          // One node is nested within another
  | 'triggers'        // One node triggers another (for integration)
  | 'consumes'        // One node consumes events from another
  | 'produces'        // One node produces events for another

// Link validation based on node types
export class CrossFeatureLinkValidator {
  static validateLink(source: BaseNode, target: BaseNode, linkType: LinkType): ValidationResult {
    // Validate that the link type makes sense for the node types
    const validCombinations = this.getValidLinkCombinations(source.featureType, target.featureType)
    
    if (!validCombinations.includes(linkType)) {
      return {
        isValid: false,
        errors: [`Link type '${linkType}' is not valid between ${source.featureType} and ${target.featureType} nodes`]
      }
    }
    
    return { isValid: true, errors: [] }
  }
  
  private static getValidLinkCombinations(sourceType: FeatureType, targetType: FeatureType): LinkType[] {
    const combinations: Record<string, LinkType[]> = {
      'function-model-knowledge-base': ['documents', 'references', 'implements'],
      'function-model-spindle': ['triggers', 'consumes', 'produces'],
      'function-model-event-storm': ['implements', 'references'],
      'knowledge-base-function-model': ['documents', 'references'],
      'knowledge-base-spindle': ['documents', 'references'],
      'knowledge-base-event-storm': ['documents', 'references'],
      'spindle-function-model': ['implements', 'supports'],
      'spindle-knowledge-base': ['consumes', 'produces'],
      'spindle-event-storm': ['consumes', 'produces'],
      'event-storm-function-model': ['triggers', 'supports'],
      'event-storm-knowledge-base': ['triggers', 'supports'],
      'event-storm-spindle': ['triggers', 'supports']
    }
    
    const key = `${sourceType}-${targetType}`
    return combinations[key] || ['references']
  }
}
```

#### 5. Unified Node Operations Interface

```typescript
// lib/use-cases/unified-node-operations.ts

export interface UnifiedNodeOperations {
  // Universal node operations (work across all node types)
  createNode<T extends BaseNode>(node: Omit<T, 'id' | 'createdAt' | 'updatedAt'>): Promise<T>
  getNode<T extends BaseNode>(featureType: FeatureType, entityId: string, nodeId?: string): Promise<T | null>
  updateNode<T extends BaseNode>(featureType: FeatureType, entityId: string, nodeId: string, updates: Partial<T>): Promise<T>
  deleteNode(featureType: FeatureType, entityId: string, nodeId: string): Promise<void>
  
  // Cross-feature operations
  createNodeLink(link: Omit<CrossFeatureLink, 'linkId' | 'createdAt' | 'updatedAt'>): Promise<CrossFeatureLink>
  getNodeLinks(featureType: FeatureType, entityId: string, nodeId?: string): Promise<CrossFeatureLink[]>
  getConnectedNodes(featureType: FeatureType, entityId: string, nodeId?: string): Promise<BaseNode[]>
  
  // Feature-specific operations (delegated to appropriate handlers)
  executeNode(featureType: FeatureType, entityId: string, nodeId: string, context?: any): Promise<any>
  validateNode(featureType: FeatureType, entityId: string, nodeId: string): Promise<ValidationResult>
  getNodeBehavior(featureType: FeatureType, entityId: string, nodeId: string): Promise<NodeBehavior>
}

// Implementation that handles node heterogeneity
export class UnifiedNodeOperationsImpl implements UnifiedNodeOperations {
  async executeNode(featureType: FeatureType, entityId: string, nodeId: string, context?: any): Promise<any> {
    const node = await this.getNode(featureType, entityId, nodeId)
    if (!node) throw new Error('Node not found')
    
    const behavior = NodeBehaviorFactory.createBehavior(node)
    
    // Execute based on node type
    switch (featureType) {
      case 'function-model':
        return await (behavior as ProcessNodeBehavior).execute()
      case 'spindle':
        return await (behavior as IntegrationNodeBehavior).connect()
      case 'knowledge-base':
        return await (behavior as ContentNodeBehavior).render()
      case 'event-storm':
        return await (behavior as DomainNodeBehavior).getState()
      default:
        throw new Error(`Unsupported feature type: ${featureType}`)
    }
  }
  
  async validateNode(featureType: FeatureType, entityId: string, nodeId: string): Promise<ValidationResult> {
    const node = await this.getNode(featureType, entityId, nodeId)
    if (!node) throw new Error('Node not found')
    
    const behavior = NodeBehaviorFactory.createBehavior(node)
    return await behavior.validate()
  }
}
```

### Database Schema Enhancements

#### 1. Feature-Specific Node Tables

```sql
-- Enhanced Function Model Nodes (Process/Workflow)
CREATE TABLE function_model_nodes (
  node_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  model_id UUID NOT NULL REFERENCES function_models(model_id),
  
  -- Base node properties
  node_type VARCHAR(50) NOT NULL,
  name VARCHAR(255) NOT NULL,
  description TEXT,
  position_x DECIMAL(10,2) DEFAULT 0,
  position_y DECIMAL(10,2) DEFAULT 0,
  
  -- Process-specific properties
  execution_type VARCHAR(20) DEFAULT 'sequential',
  dependencies TEXT[] DEFAULT '{}',
  timeout INTEGER,
  retry_policy JSONB,
  
  -- Business logic properties
  raci_matrix JSONB,
  sla JSONB,
  kpis JSONB,
  
  -- Node data (feature-specific)
  stage_data JSONB,
  action_data JSONB,
  io_data JSONB,
  container_data JSONB,
  
  -- Metadata
  metadata JSONB NOT NULL DEFAULT '{}',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Enhanced Knowledge Base Nodes (Content/Document)
CREATE TABLE knowledge_base_nodes (
  node_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  sop_id UUID NOT NULL REFERENCES knowledge_base_sops(sop_id),
  
  -- Base node properties
  node_type VARCHAR(50) NOT NULL,
  name VARCHAR(255) NOT NULL,
  description TEXT,
  position_x DECIMAL(10,2) DEFAULT 0,
  position_y DECIMAL(10,2) DEFAULT 0,
  
  -- Content-specific properties
  content_type VARCHAR(20) DEFAULT 'procedure',
  versioning_policy JSONB,
  approval_workflow JSONB,
  searchable BOOLEAN DEFAULT true,
  
  -- Content properties
  read_time INTEGER,
  complexity VARCHAR(20) DEFAULT 'moderate',
  target_audience TEXT[] DEFAULT '{}',
  prerequisites TEXT[] DEFAULT '{}',
  
  -- Node data (feature-specific)
  sop_data JSONB,
  category_data JSONB,
  template_data JSONB,
  
  -- Metadata
  metadata JSONB NOT NULL DEFAULT '{}',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Enhanced Spindle Nodes (Integration/Automation)
CREATE TABLE spindle_nodes (
  node_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  spindle_id UUID NOT NULL REFERENCES spindles(spindle_id),
  
  -- Base node properties
  node_type VARCHAR(50) NOT NULL,
  name VARCHAR(255) NOT NULL,
  description TEXT,
  position_x DECIMAL(10,2) DEFAULT 0,
  position_y DECIMAL(10,2) DEFAULT 0,
  
  -- Integration-specific properties
  integration_type VARCHAR(20) DEFAULT 'api',
  execution_mode VARCHAR(20) DEFAULT 'synchronous',
  rate_limit JSONB,
  timeout INTEGER DEFAULT 30,
  retry_policy JSONB,
  error_handling JSONB,
  
  -- Technical properties
  api_endpoint VARCHAR(500),
  authentication JSONB,
  data_mapping JSONB,
  monitoring JSONB,
  
  -- Node data (feature-specific)
  trigger_data JSONB,
  action_data JSONB,
  transformation_data JSONB,
  condition_data JSONB,
  error_handler_data JSONB,
  
  -- Metadata
  metadata JSONB NOT NULL DEFAULT '{}',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Enhanced Event Storm Nodes (Domain/Event)
CREATE TABLE event_storm_nodes (
  node_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  storm_id UUID NOT NULL REFERENCES event_storms(storm_id),
  
  -- Base node properties
  node_type VARCHAR(50) NOT NULL,
  name VARCHAR(255) NOT NULL,
  description TEXT,
  position_x DECIMAL(10,2) DEFAULT 0,
  position_y DECIMAL(10,2) DEFAULT 0,
  
  -- Domain-specific properties
  bounded_context VARCHAR(255),
  aggregate_root VARCHAR(255),
  event_sourcing BOOLEAN DEFAULT false,
  cqrs BOOLEAN DEFAULT false,
  
  -- Event properties
  event_type VARCHAR(20) DEFAULT 'event',
  event_version INTEGER DEFAULT 1,
  event_schema JSONB,
  event_handlers TEXT[] DEFAULT '{}',
  
  -- Node data (feature-specific)
  domain_data JSONB,
  event_data JSONB,
  aggregate_data JSONB,
  policy_data JSONB,
  
  -- Metadata
  metadata JSONB NOT NULL DEFAULT '{}',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

#### 2. Enhanced Cross-Feature Links

```sql
-- Enhanced Node Links with Type-Specific Context
CREATE TABLE node_links (
  link_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- Source node
  source_feature VARCHAR(50) NOT NULL,
  source_entity_id UUID NOT NULL,
  source_node_id VARCHAR(255),
  
  -- Target node
  target_feature VARCHAR(50) NOT NULL,
  target_entity_id UUID NOT NULL,
  target_node_id VARCHAR(255),
  
  -- Link properties
  link_type VARCHAR(50) NOT NULL,
  link_strength DECIMAL(3,2) DEFAULT 1.0,
  link_context JSONB NOT NULL DEFAULT '{}',
  
  -- Type-specific context (based on source and target types)
  process_context JSONB, -- For function model links
  content_context JSONB, -- For knowledge base links
  integration_context JSONB, -- For spindle links
  domain_context JSONB, -- For event storm links
  
  -- Visual properties
  visual_properties JSONB NOT NULL DEFAULT '{}',
  
  -- Metadata
  created_by UUID REFERENCES auth.users(id),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  -- Constraints
  CONSTRAINT no_self_link CHECK (
    NOT (source_feature = target_feature AND source_entity_id = target_entity_id AND source_node_id = target_node_id)
  ),
  CONSTRAINT valid_features CHECK (
    source_feature IN ('function-model', 'knowledge-base', 'event-storm', 'spindle') AND
    target_feature IN ('function-model', 'knowledge-base', 'event-storm', 'spindle')
  )
);
```

### Microservices Architecture Considerations

#### 1. Service Boundaries

```typescript
// Service boundaries based on node types
export interface ServiceBoundaries {
  functionModelService: {
    domain: 'function-model'
    responsibilities: ['process-design', 'workflow-execution', 'business-logic']
    dataOwnership: ['function_models', 'function_model_nodes']
  }
  
  knowledgeBaseService: {
    domain: 'knowledge-base'
    responsibilities: ['content-management', 'document-processing', 'search']
    dataOwnership: ['knowledge_base_sops', 'knowledge_base_nodes']
  }
  
  spindleService: {
    domain: 'spindle'
    responsibilities: ['integration-execution', 'api-management', 'automation']
    dataOwnership: ['spindles', 'spindle_nodes']
  }
  
  eventStormService: {
    domain: 'event-storm'
    responsibilities: ['domain-modeling', 'event-sourcing', 'cqrs']
    dataOwnership: ['event_storms', 'event_storm_nodes']
  }
  
  nodeLinkService: {
    domain: 'cross-feature-linking'
    responsibilities: ['link-management', 'cross-service-communication']
    dataOwnership: ['node_links', 'node_metadata']
  }
}
```

#### 2. Cross-Service Communication

```typescript
// Event-driven communication between services
export interface CrossServiceEvents {
  nodeCreated: {
    service: string
    nodeId: string
    featureType: FeatureType
    nodeType: string
    metadata: Record<string, any>
  }
  
  nodeUpdated: {
    service: string
    nodeId: string
    changes: Record<string, any>
  }
  
  nodeDeleted: {
    service: string
    nodeId: string
  }
  
  linkCreated: {
    sourceService: string
    targetService: string
    linkId: string
    linkType: LinkType
  }
}

// Service communication patterns
export interface ServiceCommunication {
  // Synchronous communication for immediate operations
  syncOperations: {
    getNode: (nodeId: string, featureType: FeatureType) => Promise<BaseNode>
    validateLink: (source: BaseNode, target: BaseNode, linkType: LinkType) => Promise<ValidationResult>
  }
  
  // Asynchronous communication for long-running operations
  asyncOperations: {
    executeNode: (nodeId: string, featureType: FeatureType) => Promise<ExecutionResult>
    processCrossFeatureLink: (linkId: string) => Promise<void>
  }
  
  // Event-driven communication for state changes
  events: {
    publishNodeEvent: (event: CrossServiceEvents[keyof CrossServiceEvents]) => Promise<void>
    subscribeToNodeEvents: (eventType: string, handler: Function) => void
  }
}
```

### Implementation Guidelines for Node Heterogeneity

#### 1. Development Approach

```typescript
// Factory pattern for creating appropriate node handlers
export class NodeHandlerFactory {
  static createHandler(node: BaseNode): NodeHandler {
    switch (node.featureType) {
      case 'function-model':
        return new ProcessNodeHandler(node as FunctionModelNode)
      case 'knowledge-base':
        return new ContentNodeHandler(node as KnowledgeBaseNode)
      case 'spindle':
        return new IntegrationNodeHandler(node as SpindleNode)
      case 'event-storm':
        return new DomainNodeHandler(node as EventStormNode)
      default:
        throw new Error(`Unknown feature type: ${node.featureType}`)
    }
  }
}

// Base handler interface
export interface NodeHandler {
  validate(): Promise<ValidationResult>
  execute(context?: any): Promise<any>
  getDependencies(): string[]
  getOutputs(): any[]
}

// Feature-specific handlers
export class ProcessNodeHandler implements NodeHandler {
  constructor(private node: FunctionModelNode) {}
  
  async validate(): Promise<ValidationResult> {
    // Validate process-specific logic
    const errors: string[] = []
    
    if (this.node.functionModelData.stage) {
      if (!this.node.functionModelData.stage.actions.length) {
        errors.push('Stage must have at least one action')
      }
    }
    
    return { isValid: errors.length === 0, errors }
  }
  
  async execute(context?: any): Promise<any> {
    // Execute process-specific logic
    const behavior = NodeBehaviorFactory.createBehavior(this.node) as ProcessNodeBehavior
    return await behavior.execute()
  }
  
  getDependencies(): string[] {
    return this.node.processBehavior?.dependencies || []
  }
  
  getOutputs(): any[] {
    // Return process outputs based on node type
    return []
  }
}

export class IntegrationNodeHandler implements NodeHandler {
  constructor(private node: SpindleNode) {}
  
  async validate(): Promise<ValidationResult> {
    // Validate integration-specific logic
    const errors: string[] = []
    
    if (this.node.spindleData.integrationType === 'api' && !this.node.technicalProperties.apiEndpoint) {
      errors.push('API nodes must have an endpoint')
    }
    
    return { isValid: errors.length === 0, errors }
  }
  
  async execute(context?: any): Promise<any> {
    // Execute integration-specific logic
    const behavior = NodeBehaviorFactory.createBehavior(this.node) as IntegrationNodeBehavior
    return await behavior.connect()
  }
  
  getDependencies(): string[] {
    // Return integration dependencies
    return []
  }
  
  getOutputs(): any[] {
    // Return integration outputs
    return []
  }
}
```

#### 2. Testing Strategy

```typescript
// Test utilities for different node types
export class NodeTestUtils {
  static createTestFunctionModelNode(): FunctionModelNode {
    return {
      id: 'test-function-model-node',
      featureType: 'function-model',
      nodeType: 'stageNode',
      name: 'Test Stage',
      description: 'Test stage for unit testing',
      position: { x: 0, y: 0 },
      visualProperties: { color: '#3B82F6' },
      metadata: { tags: ['test'] },
      createdAt: new Date(),
      updatedAt: new Date(),
      status: 'active',
      functionModelData: {
        stage: {
          id: 'test-stage',
          name: 'Test Stage',
          description: 'Test stage',
          position: { x: 0, y: 0 },
          actions: [],
          dataChange: [],
          boundaryCriteria: [],
          raci: { inform: [], consult: [], accountable: [], responsible: [] }
        }
      },
      processBehavior: {
        executionType: 'sequential',
        dependencies: [],
        timeout: 30,
        retryPolicy: { maxRetries: 3, backoff: 'exponential' }
      },
      businessLogic: {
        raciMatrix: { inform: [], consult: [], accountable: [], responsible: [] },
        sla: { responseTime: 24, availability: 99.9 },
        kpis: []
      }
    }
  }
  
  static createTestSpindleNode(): SpindleNode {
    return {
      id: 'test-spindle-node',
      featureType: 'spindle',
      nodeType: 'trigger',
      name: 'Test Trigger',
      description: 'Test trigger for unit testing',
      position: { x: 0, y: 0 },
      visualProperties: { color: '#10B981' },
      metadata: { tags: ['test'] },
      createdAt: new Date(),
      updatedAt: new Date(),
      status: 'active',
      spindleData: {
        integrationType: 'api',
        connector: { type: 'rest', method: 'GET' },
        transformation: { type: 'json', mapping: {} }
      },
      integrationBehavior: {
        executionMode: 'synchronous',
        timeout: 30,
        retryPolicy: { maxRetries: 3, backoff: 'exponential' },
        errorHandling: { strategy: 'retry', fallback: 'skip' }
      },
      technicalProperties: {
        apiEndpoint: 'https://api.example.com/test',
        authentication: { type: 'bearer', token: 'test-token' },
        dataMapping: { input: {}, output: {} },
        monitoring: { enabled: true, metrics: ['response-time', 'error-rate'] }
      }
    }
  }
}
```

## Proposed Architecture: Separate Tables with Node Connectivity

### Core Design Principles

1. **Feature Separation**: Each feature has its own dedicated table(s)
2. **Node Consistency**: All features use consistent node structure
3. **Cross-Feature Connectivity**: Nodes can connect across features
4. **Visual Mapping**: Nodes can be visualized in a unified graph
5. **Scalable Design**: Each feature can scale independently
6. **Node Heterogeneity**: Handle fundamentally different node types with unified interface

## Current State Analysis

### Unified Node System (Current)
- **Single Table**: `nodes` table stores all node types
- **Type Discrimination**: Uses `type` and `node_type` fields to distinguish features
- **Metadata Storage**: Feature-specific data stored in JSONB `metadata` field
- **Scalability Issues**: Single table becomes complex to manage at scale
- **Query Performance**: Mixed node types can impact query performance

### Function Model Feature (Current)
- **Dedicated Table**: `function_models` table with specific schema
- **Rich Metadata**: Comprehensive function model specific fields
- **Version Control**: Built-in versioning system
- **Cross-Feature Links**: Separate `cross_feature_links` table
- **Node-Level Linking**: Individual nodes can link to other features

## Proposed Architecture: Separate Tables with Node Connectivity

### Core Design Principles

1. **Feature Separation**: Each feature has its own dedicated table(s)
2. **Node Consistency**: All features use consistent node structure
3. **Cross-Feature Connectivity**: Nodes can connect across features
4. **Visual Mapping**: Nodes can be visualized in a unified graph
5. **Scalable Design**: Each feature can scale independently

### Database Schema Design

#### 1. Feature-Specific Tables

```sql
-- Function Model Feature
CREATE TABLE function_models (
  model_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(255) NOT NULL,
  description TEXT,
  version VARCHAR(50) NOT NULL DEFAULT '1.0.0',
  status VARCHAR(20) NOT NULL DEFAULT 'draft',
  
  -- Node data (React Flow)
  nodes_data JSONB NOT NULL DEFAULT '[]',
  edges_data JSONB NOT NULL DEFAULT '[]',
  viewport_data JSONB NOT NULL DEFAULT '{"x": 0, "y": 0, "zoom": 1}',
  
  -- Function Model specific
  process_type VARCHAR(100),
  complexity_level VARCHAR(20),
  estimated_duration INTEGER,
  tags TEXT[] DEFAULT '{}',
  
  -- Metadata and permissions
  metadata JSONB NOT NULL DEFAULT '{}',
  permissions JSONB NOT NULL DEFAULT '{}',
  
  -- Timestamps
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  last_saved_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  deleted_at TIMESTAMP WITH TIME ZONE,
  deleted_by UUID REFERENCES auth.users(id)
);

-- Knowledge Base Feature
CREATE TABLE knowledge_base_sops (
  sop_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  title VARCHAR(255) NOT NULL,
  content TEXT NOT NULL,
  summary TEXT,
  tags TEXT[] DEFAULT '{}',
  category VARCHAR(100),
  version VARCHAR(50) NOT NULL DEFAULT '1.0.0',
  status VARCHAR(20) NOT NULL DEFAULT 'draft',
  
  -- Node data (for visual representation)
  node_position JSONB NOT NULL DEFAULT '{"x": 0, "y": 0}',
  node_metadata JSONB NOT NULL DEFAULT '{}',
  
  -- Knowledge Base specific
  author VARCHAR(255),
  read_time INTEGER,
  search_keywords TEXT[] DEFAULT '{}',
  vector_embedding VECTOR(1536), -- For AI search
  
  -- Timestamps
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  last_viewed_at TIMESTAMP WITH TIME ZONE,
  deleted_at TIMESTAMP WITH TIME ZONE,
  deleted_by UUID REFERENCES auth.users(id)
);

-- Event Storm Feature
CREATE TABLE event_storms (
  storm_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(255) NOT NULL,
  description TEXT,
  version VARCHAR(50) NOT NULL DEFAULT '1.0.0',
  status VARCHAR(20) NOT NULL DEFAULT 'draft',
  
  -- Node data (React Flow)
  nodes_data JSONB NOT NULL DEFAULT '[]',
  edges_data JSONB NOT NULL DEFAULT '[]',
  viewport_data JSONB NOT NULL DEFAULT '{"x": 0, "y": 0, "zoom": 1}',
  
  -- Event Storm specific
  domain_context TEXT,
  time_horizon VARCHAR(50),
  tags TEXT[] DEFAULT '{}',
  
  -- Metadata
  metadata JSONB NOT NULL DEFAULT '{}',
  
  -- Timestamps
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  deleted_at TIMESTAMP WITH TIME ZONE,
  deleted_by UUID REFERENCES auth.users(id)
);

-- Spindle Feature
CREATE TABLE spindles (
  spindle_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(255) NOT NULL,
  description TEXT,
  version VARCHAR(50) NOT NULL DEFAULT '1.0.0',
  status VARCHAR(20) NOT NULL DEFAULT 'draft',
  
  -- Node data (React Flow)
  nodes_data JSONB NOT NULL DEFAULT '[]',
  edges_data JSONB NOT NULL DEFAULT '[]',
  viewport_data JSONB NOT NULL DEFAULT '{"x": 0, "y": 0, "zoom": 1}',
  
  -- Spindle specific
  spindle_type VARCHAR(50),
  complexity_level VARCHAR(20),
  tags TEXT[] DEFAULT '{}',
  
  -- Metadata
  metadata JSONB NOT NULL DEFAULT '{}',
  
  -- Timestamps
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  deleted_at TIMESTAMP WITH TIME ZONE,
  deleted_by UUID REFERENCES auth.users(id)
);
```

#### 2. Cross-Feature Node Connectivity

```sql
-- Universal Node Links Table
CREATE TABLE node_links (
  link_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- Source node (from any feature)
  source_feature VARCHAR(50) NOT NULL,
  source_entity_id UUID NOT NULL,
  source_node_id VARCHAR(255), -- Optional: specific node within entity
  
  -- Target node (to any feature)
  target_feature VARCHAR(50) NOT NULL,
  target_entity_id UUID NOT NULL,
  target_node_id VARCHAR(255), -- Optional: specific node within entity
  
  -- Link properties
  link_type VARCHAR(50) NOT NULL, -- 'references', 'implements', 'documents', 'supports', 'nested'
  link_strength DECIMAL(3,2) DEFAULT 1.0,
  link_context JSONB NOT NULL DEFAULT '{}',
  
  -- Visual properties
  visual_properties JSONB NOT NULL DEFAULT '{}', -- Color, style, etc.
  
  -- Metadata
  created_by UUID REFERENCES auth.users(id),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  -- Constraints
  CONSTRAINT no_self_link CHECK (
    NOT (source_feature = target_feature AND source_entity_id = target_entity_id AND source_node_id = target_node_id)
  ),
  CONSTRAINT valid_features CHECK (
    source_feature IN ('function-model', 'knowledge-base', 'event-storm', 'spindle') AND
    target_feature IN ('function-model', 'knowledge-base', 'event-storm', 'spindle')
  )
);

-- Node Link Types Table (for categorization)
CREATE TABLE node_link_types (
  type_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  type_name VARCHAR(50) NOT NULL UNIQUE,
  description TEXT,
  color VARCHAR(7), -- Hex color
  icon VARCHAR(50),
  is_bidirectional BOOLEAN DEFAULT false,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Insert default link types
INSERT INTO node_link_types (type_name, description, color, icon, is_bidirectional) VALUES
('references', 'One entity references another', '#3B82F6', 'link', true),
('implements', 'One entity implements another', '#10B981', 'check-circle', false),
('documents', 'One entity documents another', '#F59E0B', 'file-text', false),
('supports', 'One entity supports another', '#8B5CF6', 'shield', false),
('nested', 'One entity is nested within another', '#EF4444', 'layers', false);
```

#### 3. Node Metadata and AI Integration

```sql
-- Node Metadata Table (for shared node properties)
CREATE TABLE node_metadata (
  metadata_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- Entity reference
  feature_type VARCHAR(50) NOT NULL,
  entity_id UUID NOT NULL,
  node_id VARCHAR(255), -- Optional: specific node within entity
  
  -- Node properties
  node_type VARCHAR(50) NOT NULL,
  position_x DECIMAL(10,2) DEFAULT 0,
  position_y DECIMAL(10,2) DEFAULT 0,
  
  -- AI and search
  vector_embedding VECTOR(1536),
  search_keywords TEXT[] DEFAULT '{}',
  ai_agent_config JSONB,
  
  -- Visual properties
  visual_properties JSONB NOT NULL DEFAULT '{}',
  
  -- Metadata
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  -- Constraints
  CONSTRAINT valid_feature_type CHECK (
    feature_type IN ('function-model', 'knowledge-base', 'event-storm', 'spindle')
  )
);

-- AI Agents Table (for node-level AI integration)
CREATE TABLE ai_agents (
  agent_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- Node reference
  feature_type VARCHAR(50) NOT NULL,
  entity_id UUID NOT NULL,
  node_id VARCHAR(255),
  
  -- Agent configuration
  name VARCHAR(255) NOT NULL,
  instructions TEXT,
  tools JSONB NOT NULL DEFAULT '[]',
  capabilities JSONB NOT NULL DEFAULT '{}',
  metadata JSONB NOT NULL DEFAULT '{}',
  
  -- Status
  is_enabled BOOLEAN DEFAULT true,
  last_executed_at TIMESTAMP WITH TIME ZONE,
  
  -- Timestamps
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

### Domain Layer Design

#### 1. Base Node Interface

```typescript
// lib/domain/entities/base-node-types.ts

export interface BaseNode {
  id: string
  featureType: FeatureType
  nodeType: string
  name: string
  description?: string
  position: { x: number; y: number }
  metadata: NodeMetadata
  createdAt: Date
  updatedAt: Date
}

export interface NodeMetadata {
  tags: string[]
  visualProperties: VisualProperties
  aiAgent?: AIAgentConfig
  vectorEmbedding?: number[]
  searchKeywords: string[]
}

export interface VisualProperties {
  color?: string
  icon?: string
  size?: 'small' | 'medium' | 'large'
  style?: Record<string, any>
}

export interface AIAgentConfig {
  enabled: boolean
  instructions: string
  tools: AITool[]
  capabilities: {
    reasoning: boolean
    toolUse: boolean
    memory: boolean
    learning: boolean
  }
  metadata: {
    model: string
    temperature: number
    maxTokens: number
    contextWindow: number
  }
}

export interface AITool {
  name: string
  description: string
  parameters: Record<string, any>
  mcpServer?: string
}

export type FeatureType = 'function-model' | 'knowledge-base' | 'event-storm' | 'spindle'
```

#### 2. Node Link Interface

```typescript
// lib/domain/entities/node-link-types.ts

export interface NodeLink {
  linkId: string
  sourceFeature: FeatureType
  sourceEntityId: string
  sourceNodeId?: string
  targetFeature: FeatureType
  targetEntityId: string
  targetNodeId?: string
  linkType: LinkType
  linkStrength: number
  linkContext: Record<string, any>
  visualProperties: VisualProperties
  createdBy: string
  createdAt: Date
  updatedAt: Date
}

export type LinkType = 'references' | 'implements' | 'documents' | 'supports' | 'nested'

export interface NodeLinkType {
  typeId: string
  typeName: string
  description: string
  color: string
  icon: string
  isBidirectional: boolean
}
```

#### 3. Feature-Specific Node Types

```typescript
// lib/domain/entities/function-model-node-types.ts

export interface FunctionModelNode extends BaseNode {
  featureType: 'function-model'
  nodeType: 'stageNode' | 'actionTableNode' | 'ioNode' | 'functionModelContainer'
  functionModelData: {
    stage?: Stage
    action?: ActionItem
    io?: DataPort
    container?: FunctionModelContainer
  }
}

// lib/domain/entities/knowledge-base-node-types.ts

export interface KnowledgeBaseNode extends BaseNode {
  featureType: 'knowledge-base'
  nodeType: 'sop' | 'category' | 'template'
  knowledgeBaseData: {
    sop?: SOP
    content: string
    category: string
    status: 'draft' | 'published' | 'archived'
  }
}

// lib/domain/entities/event-storm-node-types.ts

export interface EventStormNode extends BaseNode {
  featureType: 'event-storm'
  nodeType: 'domainNode' | 'eventNode' | 'eventStormContainer'
  eventStormData: {
    domain?: Domain
    event?: Event
  }
}

// lib/domain/entities/spindle-node-types.ts

export interface SpindleNode extends BaseNode {
  featureType: 'spindle'
  nodeType: 'input' | 'default' | 'output' | 'custom'
  spindleData: {
    label: string
    description?: string
  }
}
```

### Application Layer Design

#### 1. Node Operations Use Cases

```typescript
// lib/use-cases/node-operations.ts

export interface NodeOperations {
  // Node CRUD
  createNode<T extends BaseNode>(node: Omit<T, 'id' | 'createdAt' | 'updatedAt'>): Promise<T>
  getNode<T extends BaseNode>(featureType: FeatureType, entityId: string, nodeId?: string): Promise<T | null>
  updateNode<T extends BaseNode>(featureType: FeatureType, entityId: string, nodeId: string, updates: Partial<T>): Promise<T>
  deleteNode(featureType: FeatureType, entityId: string, nodeId: string): Promise<void>
  
  // Node Links
  createNodeLink(link: Omit<NodeLink, 'linkId' | 'createdAt' | 'updatedAt'>): Promise<NodeLink>
  getNodeLinks(featureType: FeatureType, entityId: string, nodeId?: string): Promise<NodeLink[]>
  updateNodeLink(linkId: string, updates: Partial<NodeLink>): Promise<NodeLink>
  deleteNodeLink(linkId: string): Promise<void>
  
  // Cross-Feature Operations
  getConnectedNodes(featureType: FeatureType, entityId: string, nodeId?: string): Promise<BaseNode[]>
  getCrossFeatureGraph(featureTypes: FeatureType[]): Promise<{ nodes: BaseNode[], links: NodeLink[] }>
  
  // AI Integration
  createAIAgent(featureType: FeatureType, entityId: string, nodeId: string, config: AIAgentConfig): Promise<void>
  getAIAgent(featureType: FeatureType, entityId: string, nodeId: string): Promise<AIAgentConfig | null>
  updateAIAgent(featureType: FeatureType, entityId: string, nodeId: string, config: Partial<AIAgentConfig>): Promise<void>
  deleteAIAgent(featureType: FeatureType, entityId: string, nodeId: string): Promise<void>
}
```

#### 2. Feature-Specific Use Cases

```typescript
// lib/use-cases/function-model-operations.ts

export interface FunctionModelOperations {
  // Function Model CRUD
  createFunctionModel(model: Omit<FunctionModel, 'modelId' | 'createdAt' | 'updatedAt'>): Promise<FunctionModel>
  getFunctionModel(modelId: string): Promise<FunctionModel | null>
  updateFunctionModel(modelId: string, updates: Partial<FunctionModel>): Promise<FunctionModel>
  deleteFunctionModel(modelId: string): Promise<void>
  
  // Node Management within Function Model
  addNodeToFunctionModel(modelId: string, node: FunctionModelNode): Promise<FunctionModelNode>
  updateNodeInFunctionModel(modelId: string, nodeId: string, updates: Partial<FunctionModelNode>): Promise<FunctionModelNode>
  removeNodeFromFunctionModel(modelId: string, nodeId: string): Promise<void>
  
  // Cross-Feature Linking
  linkFunctionModelToKnowledgeBase(modelId: string, nodeId: string, sopId: string, linkType: LinkType): Promise<NodeLink>
  linkFunctionModelToEventStorm(modelId: string, nodeId: string, stormId: string, linkType: LinkType): Promise<NodeLink>
  linkFunctionModelToSpindle(modelId: string, nodeId: string, spindleId: string, linkType: LinkType): Promise<NodeLink>
}

// lib/use-cases/knowledge-base-operations.ts

export interface KnowledgeBaseOperations {
  // SOP CRUD
  createSOP(sop: Omit<SOP, 'id' | 'createdAt' | 'updatedAt'>): Promise<SOP>
  getSOP(sopId: string): Promise<SOP | null>
  updateSOP(sopId: string, updates: Partial<SOP>): Promise<SOP>
  deleteSOP(sopId: string): Promise<void>
  
  // Node Management within Knowledge Base
  addNodeToKnowledgeBase(sopId: string, node: KnowledgeBaseNode): Promise<KnowledgeBaseNode>
  updateNodeInKnowledgeBase(sopId: string, nodeId: string, updates: Partial<KnowledgeBaseNode>): Promise<KnowledgeBaseNode>
  removeNodeFromKnowledgeBase(sopId: string, nodeId: string): Promise<void>
  
  // Cross-Feature Linking
  linkKnowledgeBaseToFunctionModel(sopId: string, nodeId: string, modelId: string, linkType: LinkType): Promise<NodeLink>
  linkKnowledgeBaseToEventStorm(sopId: string, nodeId: string, stormId: string, linkType: LinkType): Promise<NodeLink>
  linkKnowledgeBaseToSpindle(sopId: string, nodeId: string, spindleId: string, linkType: LinkType): Promise<NodeLink>
}
```

### Infrastructure Layer Design

#### 1. Repository Pattern

```typescript
// lib/infrastructure/repositories/base-node-repository.ts

export interface BaseNodeRepository {
  // Node CRUD
  createNode<T extends BaseNode>(node: Omit<T, 'id' | 'createdAt' | 'updatedAt'>): Promise<T>
  getNode<T extends BaseNode>(featureType: FeatureType, entityId: string, nodeId?: string): Promise<T | null>
  updateNode<T extends BaseNode>(featureType: FeatureType, entityId: string, nodeId: string, updates: Partial<T>): Promise<T>
  deleteNode(featureType: FeatureType, entityId: string, nodeId: string): Promise<void>
  
  // Node Links
  createNodeLink(link: Omit<NodeLink, 'linkId' | 'createdAt' | 'updatedAt'>): Promise<NodeLink>
  getNodeLinks(featureType: FeatureType, entityId: string, nodeId?: string): Promise<NodeLink[]>
  updateNodeLink(linkId: string, updates: Partial<NodeLink>): Promise<NodeLink>
  deleteNodeLink(linkId: string): Promise<void>
  
  // AI Agents
  createAIAgent(featureType: FeatureType, entityId: string, nodeId: string, config: AIAgentConfig): Promise<void>
  getAIAgent(featureType: FeatureType, entityId: string, nodeId: string): Promise<AIAgentConfig | null>
  updateAIAgent(featureType: FeatureType, entityId: string, nodeId: string, config: Partial<AIAgentConfig>): Promise<void>
  deleteAIAgent(featureType: FeatureType, entityId: string, nodeId: string): Promise<void>
}

// lib/infrastructure/repositories/function-model-repository.ts

export interface FunctionModelRepository extends BaseNodeRepository {
  // Function Model specific operations
  createFunctionModel(model: Omit<FunctionModel, 'modelId' | 'createdAt' | 'updatedAt'>): Promise<FunctionModel>
  getFunctionModel(modelId: string): Promise<FunctionModel | null>
  updateFunctionModel(modelId: string, updates: Partial<FunctionModel>): Promise<FunctionModel>
  deleteFunctionModel(modelId: string): Promise<void>
  
  // Node operations within Function Model
  addNodeToFunctionModel(modelId: string, node: FunctionModelNode): Promise<FunctionModelNode>
  updateNodeInFunctionModel(modelId: string, nodeId: string, updates: Partial<FunctionModelNode>): Promise<FunctionModelNode>
  removeNodeFromFunctionModel(modelId: string, nodeId: string): Promise<void>
}

// lib/infrastructure/repositories/knowledge-base-repository.ts

export interface KnowledgeBaseRepository extends BaseNodeRepository {
  // Knowledge Base specific operations
  createSOP(sop: Omit<SOP, 'id' | 'createdAt' | 'updatedAt'>): Promise<SOP>
  getSOP(sopId: string): Promise<SOP | null>
  updateSOP(sopId: string, updates: Partial<SOP>): Promise<SOP>
  deleteSOP(sopId: string): Promise<void>
  
  // Node operations within Knowledge Base
  addNodeToKnowledgeBase(sopId: string, node: KnowledgeBaseNode): Promise<KnowledgeBaseNode>
  updateNodeInKnowledgeBase(sopId: string, nodeId: string, updates: Partial<KnowledgeBaseNode>): Promise<KnowledgeBaseNode>
  removeNodeFromKnowledgeBase(sopId: string, nodeId: string): Promise<void>
}
```

### Presentation Layer Design

#### 1. Unified Node Visualization

```typescript
// components/composites/unified-node-graph.tsx

interface UnifiedNodeGraphProps {
  nodes: BaseNode[]
  links: NodeLink[]
  onNodeClick?: (node: BaseNode) => void
  onLinkClick?: (link: NodeLink) => void
  onNodeDrag?: (nodeId: string, position: { x: number; y: number }) => void
  onLinkCreate?: (source: string, target: string, linkType: LinkType) => void
}

export function UnifiedNodeGraph({
  nodes,
  links,
  onNodeClick,
  onLinkClick,
  onNodeDrag,
  onLinkCreate
}: UnifiedNodeGraphProps) {
  // React Flow implementation for unified node visualization
  // Handles different node types with consistent visual representation
  // Supports cross-feature linking and navigation
}
```

#### 2. Feature-Specific Node Components

```typescript
// components/composites/function-model/function-model-node.tsx

interface FunctionModelNodeProps {
  node: FunctionModelNode
  onEdit?: (node: FunctionModelNode) => void
  onDelete?: (nodeId: string) => void
  onLink?: (nodeId: string, targetFeature: FeatureType, targetId: string) => void
}

export function FunctionModelNode({
  node,
  onEdit,
  onDelete,
  onLink
}: FunctionModelNodeProps) {
  // Function Model specific node rendering
  // Includes stage, action, IO, container visualizations
}

// components/composites/knowledge-base/knowledge-base-node.tsx

interface KnowledgeBaseNodeProps {
  node: KnowledgeBaseNode
  onEdit?: (node: KnowledgeBaseNode) => void
  onDelete?: (nodeId: string) => void
  onLink?: (nodeId: string, targetFeature: FeatureType, targetId: string) => void
}

export function KnowledgeBaseNode({
  node,
  onEdit,
  onDelete,
  onLink
}: KnowledgeBaseNodeProps) {
  // Knowledge Base specific node rendering
  // Includes SOP, category, template visualizations
}
```

### Migration Strategy

#### Phase 1: Database Schema Migration

1. **Create New Tables**: Implement separate feature tables
2. **Data Migration**: Migrate existing unified node data to feature-specific tables
3. **Link Migration**: Migrate existing relationships to new node_links table
4. **Validation**: Ensure data integrity and consistency

#### Phase 2: Domain Layer Migration

1. **Update Types**: Implement new base node and feature-specific types
2. **Repository Updates**: Update repositories to use new schema
3. **Use Case Updates**: Update use cases to work with new structure
4. **Validation**: Ensure business logic remains intact

#### Phase 3: Application Layer Migration

1. **Hook Updates**: Update custom hooks to work with new structure
2. **State Management**: Update state management for new node structure
3. **Cross-Feature Integration**: Implement new cross-feature linking
4. **Testing**: Comprehensive testing of all features

#### Phase 4: Presentation Layer Migration

1. **Component Updates**: Update components to use new node structure
2. **Visual Integration**: Implement unified node visualization
3. **Cross-Feature Navigation**: Update navigation between features
4. **User Experience**: Ensure seamless user experience

### Benefits of This Architecture

#### 1. Scalability
- **Separate Tables**: Each feature can scale independently
- **Optimized Queries**: Feature-specific queries are more efficient
- **Independent Development**: Features can evolve independently

#### 2. Maintainability
- **Clear Separation**: Each feature has its own domain and infrastructure
- **Reduced Complexity**: No single table managing all node types
- **Easier Debugging**: Issues are isolated to specific features

#### 3. Flexibility
- **Feature-Specific Logic**: Each feature can implement its own business logic
- **Custom Fields**: Features can have their own specific fields
- **Independent Evolution**: Features can add new capabilities without affecting others

#### 4. Cross-Feature Connectivity
- **Unified Links**: Single table manages all cross-feature relationships
- **Visual Mapping**: Nodes can be visualized in a unified graph
- **Consistent Interface**: All features use the same node linking interface

#### 5. Future-Proofing
- **AI Integration**: Built-in support for AI agents at the node level
- **Vector Search**: Support for semantic search across all features
- **Extensibility**: Easy to add new features or node types

### Implementation Guidelines

#### 1. Development Approach
- **Incremental Migration**: Migrate one feature at a time
- **Backward Compatibility**: Maintain compatibility during transition
- **Comprehensive Testing**: Test each feature thoroughly after migration

#### 2. Performance Considerations
- **Indexing**: Proper indexing on all tables for optimal performance
- **Query Optimization**: Optimize queries for feature-specific operations
- **Caching**: Implement caching for frequently accessed data

#### 3. Security Considerations
- **Row Level Security**: Implement RLS on all tables
- **Access Control**: Feature-specific access control
- **Audit Logging**: Comprehensive audit logging for all operations

#### 4. Monitoring and Maintenance
- **Performance Monitoring**: Monitor query performance and optimize
- **Data Integrity**: Regular checks for data consistency
- **Backup Strategy**: Comprehensive backup and recovery strategy

## Conclusion

This node-based architecture design provides a scalable, maintainable, and flexible solution that addresses the limitations of a unified node system while preserving the benefits of node-based connectivity. The separate table approach allows each feature to scale independently while the unified linking system enables rich cross-feature relationships and visual mapping.

The architecture maintains Clean Architecture principles while providing a solid foundation for future growth and AI integration. The migration strategy ensures a smooth transition from the current unified system to the new architecture without disrupting existing functionality. 