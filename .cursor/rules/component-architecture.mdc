---
description: When creating features, build modular UI components for presentation
globs:
  - "components/**/*.tsx"
  - "app/**/*.tsx"
  - "lib/application/hooks/**/*.ts"
alwaysApply: false
---
# Component Architecture

## Table of Contents
1. [Introduction](#introduction)
2. [Component-Based Design Principles](#component-based-design-principles)
3. [Clean Architecture as Our Foundation](#clean-architecture-as-our-foundation)
4. [Our Modified Component Architecture](#our-modified-component-architecture)
   - [Base Components](#base-components)
   - [Composite Components](#composite-components)
   - [Feature Components](#feature-components)
   - [Page Components](#page-components)
5. [Component Relationships and Flow](#component-relationships-and-flow)
6. [Tool Stack and Implementation](#tool-stack-and-implementation)
7. [Best Practices](#best-practices)
8. [Examples from Our Codebase](#examples-from-our-codebase)
9. [Future Considerations](#future-considerations)

## Introduction

This application follows a carefully designed component architecture that combines the principles of Clean Architecture with a modified Component-Based Design approach. This document outlines how these architectural patterns work together to create a maintainable, scalable, and efficient frontend application.

Our architecture is designed to support the application's current needs while remaining flexible enough to accommodate future growth, whether that involves expanding features within the monolithic structure or potentially transitioning to microservices.

## Component-Based Design Principles

Component-Based Design (CBD) is a software engineering approach that emphasizes building applications using modular, reusable components. These components act as independent building blocks that work together to form a complete system while remaining decoupled from each other.

### Core Principles of Component-Based Design:

1. **Single Responsibility Principle**: Each component should ideally do one thing and do it well. If a component grows too large or handles too many responsibilities, it should be decomposed into smaller subcomponents.

2. **Encapsulation**: Components should encapsulate their implementation details, exposing only the necessary interfaces for interaction. This hides complexity and prevents tight coupling.

3. **Reusability**: Components should be designed to be reused across different parts of the application or even in different projects.

4. **Composability**: Smaller components should be easily combined to create larger, more complex components.

5. **Isolation**: Components should be isolated from each other, minimizing dependencies and allowing for independent development and testing.

6. **Statelessness**: When possible, components should be stateless, receiving data through props and emitting events rather than managing their own state.

7. **Declarative Interfaces**: Components should have clear, declarative interfaces that make their usage intuitive and self-documenting.

## Clean Architecture as Our Foundation

Clean Architecture serves as the foundational architectural pattern for the entire application. It provides a clear separation of concerns across four distinct layers:

1. **Domain Layer**: Contains core business entities and types
   - Located in `/lib/types/`
   - Defines the fundamental data structures and interfaces used throughout the application
   - Example: Data type definitions for core business entities

2. **Application Layer**: Implements business logic and use cases
   - Located in `/lib/utils/` and `/lib/hooks/`
   - Contains business logic, calculations, and transformations
   - Example: Calculation utilities for business metrics

3. **Infrastructure Layer**: Handles external interfaces and technical concerns
   - Located in `/lib/services/` and `/lib/repositories/`
   - Manages communication with external systems (Supabase, APIs)
   - Example: Repository modules that handle data access for specific features

4. **Presentation Layer**: Manages UI components and user interaction
   - Located in `/components/` and `/app/`
   - Renders the user interface and handles user interactions
   - Example: Feature-specific UI components in their respective directories

The key benefit of Clean Architecture is that it creates a system where business rules and application logic are independent of external frameworks, databases, and UI components. This makes the system more testable, maintainable, and adaptable to change.

## Our Modified Component Architecture

For our frontend implementation, we've adopted a modified Component-Based Design approach that complements Clean Architecture. Our component hierarchy is organized into four main categories:

### Base Components

Base components are the fundamental building blocks of our UI. They are:
- Simple, focused components with a single responsibility
- Highly reusable across the entire application
- Generally stateless, receiving data via props
- Styled using Tailwind CSS with consistent design patterns

**Location**: `/components/ui/`

**Examples**:
- Button
- Input
- Card
- Modal
- Dropdown

### Composite Components

Composite components combine multiple base components to create more complex UI elements with specific functionality:
- Composed of multiple base components working together
- Encapsulate related UI logic and interactions
- Still relatively generic and reusable across different features
- May maintain their own internal state

**Location**: `/components/composites/`

**Examples**:
- DataTable (combines Table, Pagination, Search, Filter components)
- MetricsGrid (arranges multiple metric cards in a responsive grid)
- DateRangePicker (combines calendar inputs with preset options)
- DashboardFilters (combines various filter inputs for dashboards)

### Feature Components

Feature components are specialized for specific business features:
- Built using base and composite components
- Implement specific business logic for a particular feature
- Closely tied to the domain model and application logic
- May interact with hooks and services to fetch and manipulate data

**Location**: `/app/(private)/dashboard/[feature]/components/`

**Examples**:
- FeatureSummary (in feature-specific component directories)
- DataListingTable (in data listing feature directories)
- FeatureKpiCards (in feature dashboard component directories)

### Page Components

Page components represent entire pages or major sections of the application:
- Compose feature components to create complete pages
- Handle page-level state and data fetching
- Manage routing and navigation concerns
- Implement layout and page structure

**Location**: `/app/(private)/dashboard/[feature]/page.tsx`

**Examples**:
- Feature Dashboard Page
- Data Analytics Dashboard Page
- User Management Page

## Component Relationships and Flow

Our component architecture follows a clear flow of data and composition:

1. **Composition Flow**: 
   - Page Components → Feature Components → Composite Components → Base Components

2. **Data Flow**:
   - Data typically flows down from page components to feature components to composite components to base components
   - Events and user interactions flow up in the opposite direction

3. **Clean Architecture Integration**:
   - Page and Feature components interact with the Application Layer through custom hooks
   - Custom hooks interact with the Infrastructure Layer through services and repositories
   - Services and repositories interact with external systems (Supabase, APIs)

This approach ensures a clear separation of concerns while maintaining a modular, reusable component structure.

## Tool Stack and Implementation

Our component architecture is implemented using the following technologies:

### Frontend Framework
- **Next.js 14.2.4** (React 18): Provides the foundation for our component-based architecture with server-side rendering capabilities

### Component Styling and UI
- **Tailwind CSS**: Utility-first CSS framework for styling components
- **shadcn/ui**: Component library built on Radix UI primitives
- **Radix UI**: Provides accessible, unstyled UI primitives

### State Management
- **React Hooks**: useState, useContext, and custom hooks for state management
- **URL Parameters**: For shareable, bookmarkable states

### Form Handling
- **React Hook Form**: For form state management and validation
- **Zod**: For schema validation

### Data Visualization
- **Recharts**: For creating data visualizations and charts

### Date Handling
- **date-fns**: For date manipulation and formatting

## Best Practices

To maintain the integrity of our component architecture, we follow these best practices:

### Component Design
1. **Single Responsibility**: Each component should have a single, well-defined responsibility
2. **Proper Naming**: Use clear, descriptive names that indicate the component's purpose
3. **Consistent Props API**: Design consistent, intuitive props interfaces
4. **Documentation**: Document component props, usage, and examples

### State Management
1. **Minimize State**: Keep state as close as possible to where it's needed
2. **URL Parameters**: Use URL parameters for shareable filter state
3. **Custom Hooks**: Extract complex state logic into custom hooks
4. **Avoid Prop Drilling**: Use context or custom hooks for deeply nested state needs

### Performance
1. **Memoization**: Use React.memo, useMemo, and useCallback appropriately
2. **Code Splitting**: Leverage Next.js's automatic code splitting
3. **Lazy Loading**: Implement lazy loading for large components when appropriate
4. **Virtualization**: Use virtualization for long lists (react-window or react-virtualized)

### Testing
1. **Component Testing**: Write tests for component rendering and interactions
2. **Hook Testing**: Test custom hooks independently
3. **Integration Testing**: Test component compositions and interactions
4. **Accessibility Testing**: Ensure components meet accessibility standards

## Examples from Our Codebase

### DataTable Component

The DataTable component is an excellent example of our component architecture in action:

1. **Base Components**: Uses Table, TableHeader, TableRow, TableCell from shadcn/ui
2. **Composite Component**: DataTable in `/components/composites/data-table/`
   - Combines search, filtering, pagination, and sorting
   - Provides a consistent interface for all tables in the application
3. **Feature Component**: FeatureDataTable in `/app/(private)/dashboard/feature/data-view/`
   - Uses DataTable with specific columns and data for the feature
   - Implements feature-specific functionality
4. **Page Component**: Feature view page that incorporates the FeatureDataTable

This hierarchy demonstrates how our component architecture enables code reuse while maintaining separation of concerns.

### Feature Dashboard

The Feature Dashboard showcases Clean Architecture principles:

1. **Domain Layer**: Types in `/lib/types/feature-types.ts`
2. **Application Layer**: Calculations in `/lib/utils/feature/calculations.ts`
3. **Infrastructure Layer**: Data fetching in `/lib/hooks/use-feature-data.ts`
4. **Presentation Layer**: Components in `/app/(private)/dashboard/feature/components/`

This separation allows each layer to evolve independently while maintaining clear boundaries between concerns.

## Future Considerations

As the application continues to evolve, our component architecture provides a solid foundation for future growth:

1. **Microfrontends**: The clear component boundaries could facilitate a transition to microfrontends if needed
2. **Design System**: Our base and composite components could evolve into a formal design system
3. **Component Library**: We could extract reusable components into a shared library for use across multiple projects
4. **Server Components**: Next.js server components could be further leveraged to optimize performance

By maintaining our modified Component-Based Design approach within the Clean Architecture framework, we ensure that the application remains maintainable, scalable, and adaptable to changing requirements.
